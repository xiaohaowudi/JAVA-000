## 第六周学习总结
本周学习内容主要有两部分，第一部分是对一些通用的编码技能的学习，和一些简单的数据库知识的回顾，要点总结如下：

### Lambda表达式
Lambda表达式是一种实现函数式编程的方式，在许多语言中都是默认就已经有的，Java语言在Java8时候进行了引入，C++也是在C++11标准才引入Lambda特性的，虽然是一个在其他语言中比较常见的特性，但是在Java和C++中引入都是近些年事情，Lambda的本质就是匿名的带状态的可执行对象，在Java中的实现形式是一系列被@FunctionalInterface修饰的接口的实现类的实例，而在C++中是以STL中的Function模板类作为Lambda对象的类型，各种不同的语言对Lambda的实现形式也有所不同，但是本质上没有大的区别，能够大幅缩减代码编写的复杂度，让代码表达的逻辑更加简洁，体现的是一种函数式的思想，将处理逻辑实现在可执行对象中，可将其传递给业务框架，由业务框架调度其行为运行的时机，可以很方便实现业务和逻辑的分离

Java库中比较常见的Lambda表达式先关的接口有如下几种
1. Predicate<T>  有参数的条件判断，实现断言功能，其test方法返回boolean类型判断结果，其实现类需要对该方法进行实现
2. Function<T，R> 有单个参数，有返回值的可执行对象 核心方法是apply compose andThen三个
  
  apply 方法在Function接口中没有默认实现，需要实现类自己进行逻辑实现，apply(t)表示在当前Lambda对象上执行以t为参数的操作，返回R类型结果
  
  compose 方法在Function接口中有默认实现，其功能是组合当前对象和传入的before对象，返回新包装出来的Lambda对象，返回的包装对象的执行逻辑是先执行before对象中的操作，其操作结果再作为当前对象的参数进行执行，最终返回执行结果
  
  andThen 方法在Function接口中也有默认实现，其功能刚好和compose相反，也是包装一个新的Lambda对象，该对象的执行逻辑是先执行当前对象的运算，然后将执行结果作为after对象的执行参数，最终返回after对象的执行结果
  
  通过 compoose 和 andThen 两个方法的组合调用可以灵活地将多个Lambda对象按特性顺序进行组合包装，互相复用对方的功能
  
3. Consumer<T> 无返回值的数据消费者
4. Supplier<T> 无参数，有返回值的执行对象，相当于数据提供者
5. BiFunction<T, U, R> 两个参数，有返回值的可执行对象，主要方法接口是andThen，能够传入一个一元运算Lambda对象after和当前对象做组合，返回一个包装Lambda对象，将当前二元运算的结果作为一元运算after的参数进行计算，最终返回after对象执行的结果
  
  compose 和 andThen 是各种不同类型的Lambda接口的核心方法，本质是一种装饰模式对功能进行包装增强的应用

### Stream
Java8引入的流操作给可迭代对象中的元素提供了一种顺序执行一系列操作并最终进行聚合的运算方式，跟MapReduce的计算框架本质思想是一致的，在Python语言中原生就有map reduce 高阶函数的实现，而Java对于这样的计算方式是以新语言特性在近年进行引入
流的操作类型分为两种：

中间操作 ：一个流可以后面跟随零个或多个中间操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的，仅仅调用到这类方法，并没有真正开始流的遍历

典型的中间操作：
filter: 过滤器

map: 映射

faltMap: 传入的lambda吧每一个元素转换为一个流，然后该函数将所有流串接起来，构造出一个新的流

distict: 去重

limit: 保留前N个元素

skip: 滤除前N个元素

sorted: 生成排序后新流

终止操作 ：一个流只能有一个终止操作操作，当这个操作执行后，流就被使用完结，无法再被操作。终止操作的执行，才会真正开始流的遍历，并且会生成一个结果。
典型的终止操作

reduce: 聚合

collect: 流转换为集合

forEach: 迭代

allMatch: 检查是否所有元素匹配

anyMatch: 检查是否至少有一个元素匹配

noneMatch: 检查是否没有元素匹配

finddFirst: 返回流中第一个元素

findAny: 返回流中任意元素

count: 返回流中元素个数

max/min 返回流中的最大/最小值

Java中流操作也是一种函数式编程的体现，以链式编程的形式组合了计算业务，而计算业务的具体逻辑以Lambda对象的形式作为参数传入，最终以链条形式顺序执行流中的操作，跟Spark大数据框架中惰性计算的思维本质上是一样的，是一种比较通用的计算结构

### Lombok
本质上是利用注解对类功能进行编译期增强的技术，可以通过注解方式方便地对常见的构造方法，ToString，Getter, Setter等方法进行隐式添加，可大量减少冗杂重复代码的编写

同时本周还对设计原则，设计模式进行了简单回顾，SOLID原则，GOF23设计模式都是老生常谈的基本知识，是每一个合格的程序员必须深入学习的知识，时刻把握好设计原则，才能写出合格的，拓展性强的代码，这也是IT从业人员的基本素质，除此之外UnitTest，Guava等工具的掌控也可以更好地辅助开发，都是必备技能，然而这两块内容自己并不是十分熟悉，后续还需要投入些时间深入学习

本周第二部分对数据库知识进行了回顾，对关系型数据库中的设计范式，SQL语句的分类和MySQL数据库的基本原理进行了学习，要点总结如下：
### 大型系统中数据库涉及到的非功能性指标
运行效率

数据一致性

高可用

稳定性

可维护性

对于运行多年老系统而言，大概率性能瓶颈会出现在会在数据库上，当对大型系统进行性能优化时候，可以优先关注数据库的优化，其中涉及库表结构优化，事务优化，SQL优化等等


### RDBMS概念
关系型数据库，基于关系代数构建的数据存储系统，可以基于实体关系模型对数据进行操作，实体对应数据库中的表，属性对应表中的列，实体的一个实例对应表中的一行，实体和实体之间通过关系代数相互关联


### 数据库的设计范式
用于约束关系代数系统实现的指导原则，现也用于约束关系型数据库的设计实现，主要有6种范式
第一范式：每一个属性的数值都是不可分割的原子项
具体体现形式就是表中的额每一列都是不可再分解的基本数据项

第二范式：满足第一范式前提下，消除非主属性对码的部分函数依赖
具体体现形式是表中的任何一行的数值都能被主键(或者联合主键)唯一标识或者确定，每一个属性都是和主键有直接关系的

第三范式：满足第二范式前提下，消除非主属性对码的传递函数依赖
具体体现形式是表中没有任何一列是和主键不相关的，如果和主键不想管，应该拆分为新实体中的属性

BC范式：满足三范式前提下，消除主尚需经对码的部分函数和传递函数的依赖

第四范式：满足三范式前提下，消除非平凡的多值依赖

第五范式：满足四范式前提下，消除一些不合适的连接依赖

范式是设计数据库指导思想，但是不是铁律，具体业务中需要灵活折衷

### 6种SQL分类
1、数据查询语言(DQL: Data Query Language): 数据检索语句，用以从 表中获得数据，确定数据怎样在应用程序给出，典型的是SELECT。

2、数据操作语言(DML:Data Manipulation Language):其语句包括动词INSERT、 UPDATE和DELETE。它们分别用于添加、修改和删除。

3、事务控制语言(TCL):它的语句能确保被DML语句影响的表的所有行及时得以更新。包括 COMMIT(提交)命令、SAVEPOINT(保存点)命令、ROLLBACK(回滚)命令。

4、数据控制语言(DCL):它的语句通过GRANT或REVOKE实现权限控制，确定单个用户和用户 组对数据库对象的访问。某些RDBMS可用GRANT或REVOKE控制对表单个列的访问。

5、数据定义语言(DDL):其语句包括动词CREATE,ALTER和DROP。在数据库中创建新表或修 改、删除表(CREAT TABLE 或 DROP TABLE);为表加入索引等。

6、指针控制语言(CCL):典型的包括DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT， 用于对一个或多个表单独行的操作。

### MySQL基本架构
<img src="https://github.com/xiaohaowudi/JAVA-000/blob/main/Week_06/image/MySQL%E6%9E%B6%E6%9E%84%E5%9B%BE.png" width="60%" height="60%" />

### MySQL中SQL执行基本流程

<img src="https://github.com/xiaohaowudi/JAVA-000/blob/main/Week_06/image/MySQL%E7%AE%80%E5%8D%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" height="60%" width="60%"/>


1. 查询缓存有没有已经执行过的缓存结果，如果有直接返回结果
2. 解析器解析SQL语句为语法树，进入预处理器进行处理
3. 优化器优化SQL的执行操作生成最终的执行计划
4. 调用存储引擎的接口完成执行计划
5. 将结果集返回给客户端

### 一条SQL语句的执行顺序
1. from 子句：从表中提取数据
2. on join子句： 根据属性值对多个表进行连接操作
3. where子句： 根据条件对结果集进行过滤
4. gorup by: 对数据进行分组
5. having + 聚合函数： 每个分组中进行过滤和聚合
6. select: 在结果集中选择属性列
7. order by: 对结果进行排序
8. limit: mysql特有，截断结果集后面部分，只保留前面固定数量的记录

### MySQL索引结构
B+树结构实现聚集索引，在特定的一棵索引树上查找到目标对象的时间复杂度是log(N), 其中log表示以k为底的对数，N为叶子节点个数，k为B+树节点的分叉数，也就是和树高度呈线性关系，层数越少查询效率越高，也能够尽量避免磁盘IO，建议一般单表数据不要超过2000万条

### 常见的MySQL优化参数
1. max_connections
2. back_log
3. wait_timeout
4. interative_timeout
4、key_buffer_size
5. query_cache_size
6. max_connect_errors
7. sort_buffer_size
8. max_allowed_packet
9. join_buffer_size
10. thread_cache_size=300
11. innodb_buffer_pool_size
12. innodb_flush_log_at_trx_commit
13. innodb_thread_concurrency
14. innodb_log_buffer_size
15. innodb_log_file_size=50M
16. innodb_log_files_in_group=3
17. read_buffer_size=1M
18. read_rnd_buffer_size
19. bulk_insert_buffer_size
20. binary log

### 数据库设计常见的一些最佳实践
1. 需要根据存储引擎的特性和数据的特点选择使用的存储引擎，并不是所有数据都用InnoDB引擎就是最好的
2. 合理拆分宽表，合理应用数据库设计范式对库表结进行约束
3. 属性的数据类型选择要明确，长度尽量短，这样能够提升数据库效率，text/blob/clob这样长度不固定的数据类型不建议放到RDBMS中存储，会拖慢数据库运行效率，可以考虑放到其他文件系统中存储
4. 时间最好使用时间戳方式存储，对计算友好
5. 对于高精度浮点数可以考虑用 整数+精度 或者 字符串+精度 的方式进行存储，规避浮点数精度不足造成的问题
6. 外键和触发器不建议使用
7. 可以适当破坏范式，增加一些冗余字段，让业务处理更加方便高效
8. 游标，变量，视图，自定义函数，存储过程大多数场景下不建议使用, 难以维护
9. 在线DDL操作会有比较重型加锁行为，会造成业务阻塞，建议在业务压力小时候进行
10. 建议添加create_time, update_time时间戳，方便业务处理

























