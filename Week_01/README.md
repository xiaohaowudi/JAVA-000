# 知识要点总结
# 1. JVM基本知识
## 1.1 Java语言本身的特点
面向对象的基于JVM虚拟机的半编译半解释型语言， 支持GC垃圾回收，支持二进制跨平台, 生态完整，生命力强
Java相对C++, Rust等其他语言的优势和劣势：
具备比较完善的GC机制，将内存的管理和回收都由JVM完成，对象的生命周期由JVM管理，设计哲学上讲，完全不信任程序员对内存的管理行为，一方面讲，将开发者从C++那样复杂的内存管理中解放出来，能够更多关注在业务逻辑上，但是同时也引入了GC的开销，在GC使用不当情况下会影响业务效率

## 1.2 Java程序运行基本机制
<img src="https://github.com/xiaohaowudi/JAVA-000/blob/main/Week_01/images/Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.png" width="35%" height="35%" />


应用开发者利用java编译器将java代码编译为字节码，每一个类对应一个字节码文件，程序运行时候首先是JVM虚拟机进程启动，作为所有Java程序的运行容器，由类装载器将类的字节码加载到内存中，加载到内存中的类就可以生成响应的对象，各个对象在特定的Java线程中运行自己的业务逻辑

## 1.3 字节码技术
### 1.3.1 字节码的作用
Java程序本质上运行机制是由JVM执行Java源文件生成的字节码，可类比C++层序运行时候是由CPU运行汇编指令来理解，字节码本质就是JVM指令的二进制表现，通常通过类似于汇编的助记符提供给开发者阅读，可以通过javap等工具将二进制字节码反编译为助记符，开发者可通过程序的字节码分析代码逻辑并定位一些性能问题，JVM的字节码操作码由一个字节表示，至多支持256中不同操作码，除了一部分留给调试使用以外，现在已经使用的JVM指令操作码大概200个左右

### 1.3.2 字节码分类
a. 栈操作指令，作用是操作栈帧中的栈结构和局部变量表，完成计算功能

b. 流程控制指令，完成goto, for, if等判断逻辑

c. 对象操作和方法调用指令

典型的方法调用指令:

&nbsp;&nbsp;&nbsp;&nbsp;**invokestatic** 用于调用静态方法

&nbsp;&nbsp;&nbsp;&nbsp;**invokespecial** 用于调用构造函数

&nbsp;&nbsp;&nbsp;&nbsp;**invokevirtual** 用于对象引用调用多态

&nbsp;&nbsp;&nbsp;&nbsp;**invokeinterface** 用于接口调用方法

&nbsp;&nbsp;&nbsp;&nbsp;**invokedynamic** JDK7新增加，用于实现动态类型语言，lambda表达式实现的基础指令

d. 算数运算和类型转换

### 1.3.3 JVM执行字节码的核心内存结构

*栈帧结构和load/store机制*

<img src="https://github.com/xiaohaowudi/JAVA-000/blob/main/Week_01/images/load:store%E6%9C%BA%E5%88%B6.png" width="35%" height="35%" />
<img src="https://github.com/xiaohaowudi/JAVA-000/blob/main/Week_01/images/Java%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84.png" width="35%" height="35%" />


a. **栈结构** 栈结构是线程栈帧中一部分，类似于CPU中ALU的功能，用于缓存运算需要的参数，一般字节码运行时候基于栈的后入先出的机制读取参数，参数读取完之后进行弹栈，指令运行完后，如果有运行结果，将结果存储于栈顶，后面的指令从栈顶读取前面指令的运行结果，对于栈操作分为load和store两种，load类指令将局部变量表中的数值加载到栈顶，store类指令将栈顶数据弹栈并根据槽位号存储到局部变量表的对应位置

b. **局部变量表** 线程栈帧的组成部分，类似于CPU中通用寄存器的功能，用于保存临时变量，每一个槽位都绑定一个局部变量，本质是内存中的一个数组，指令运行时候数据会在栈和局部变量表之间以load/store方式进行交互


## 1.4 类加载器原理

### 1.4.1 Java类的声明周期
类加载器本质功能是通过一系列步骤将字节码文件加载到JVM内存中，供JVM使用，典型的类的生存周期有7个阶段：
<img src="https://github.com/xiaohaowudi/JAVA-000/blob/main/Week_01/images/Java%E7%B1%BB%E7%9A%84%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F.png" width="75%" height="75%" />
1. 加载 根据ClassPath等信息查找Class文件
2. 验证 验证字节码文件的格式和依赖
3. 准备 构造静态字段，方法表
4. 解析 将符号解析为真正的引用
5. 初始化 静态变量赋值，静态代码块执行
6. 使用 具体线程中对类进行使用
7. 卸载

### 1.4.2 类加载的场景和时机
1. 程序入口执行静态的main方法时候，会触发main函数所在的类的加载
2. 调用new创建类A对象时候，会触发加载类A
3. 调用类A的静态方法时候，会触发加载类A
4. 访问类A的静态数据字段时候，会触发加载类A
5. 子类被加载时候会先触发其父类的加载
6. 如果接口中实现了default方法，直接或者间接实现了该接口的类被加载时候会先触发该接口类的加载
7. 用反射API对类进行操作时候，会触发该类的加载
8. 初次调用MethodHandle时候，会触发该MethodHandle指向的方法所在的类的加载

### 1.4.3 类加载但是不初始化的场景
1. 子类引用了父类的静态字段，会触发父类的初始化，但是不会触发子类本身的初始化
2. 创建类A的对象数组(本质是构造引用数组), 类A会被加载，但是不会触发初始化
3. 对常量的引用不会触发该常量所在的类的初始化，因为常量本质是存放在常量池的，其数值在编译器已经确定，不依赖于其所在类的初始化
4. 通过类A.class方式引用A的Class对象，不会直接触发类A的初始化，除非用该Class对象实例化该类的对象或者访问了该类的静态字段或者方法
5. Class.forName加载指定类时候，如果initialize参数传递false，不会触发该类的初始化
6. 通过ClassLoader默认的loadClass方法加载类，不会触发类的初始化

### 1.4.4 类加载器的3种分类
1. **启动类加载器(BootstrapClassLoader)** 加载JVM依赖的最核心的系统类，例如rt.jar包中的类
2. **拓展类加载器(ExtClassLoader)** 加载拓展类路径下的类
3. **应用类加载器(AppClassLoader)** 加载应用开发者自己编写的类或者jar包

### 1.4.5 类加载器的运行原则
1. **双亲委托** 当前级别的类加载器加载类时候会先查看其上一级的类加载器有没有加载对应的类，如果已经加载了则直接使用
*类加载器的层级关系*

<img src="https://github.com/xiaohaowudi/JAVA-000/blob/main/Week_01/images/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png" width="60%" height="60%" />


### 小结
本周简单学习了JVM的字节码原理，类装载器原理和JVM内存模型，在读书时候曾经接触过这些知识，但是没有非常深入去看，在老师讲解之后，自己动手写了几个实例程序用javap进行解析然后分析其字节码，其实Java字节码系统相对于硬件CPU的指令集系统已经简单了非常多，以前有过ARM平台上汇编代码的分析经验，再看Java的字节码系统，相对简单很多，Java字节码指令集本身很精简，LOAD STORE机制以及局部变量表配合一个内部栈进行计算，跟CPU中通用寄存器组配合ALU做算数运算的原理如出一辙。JMM内存模型相对以前有了一些更新换代，但是本质设计思想还是没有大的变化，趁着训练营机会正好把这些年没怎么关注的Java这一块的更新内容学习一下，装载器原理在读书时候就有过接触，通过作业中的简单代码事件也加深了一下理解，总体讲本节课涉及的内容大部分在读书时候接触过，少部分内容是自己盲区，不太了解，通过老师讲解和课后查阅资料已经进行了补习，作业内容相对简单，做起来没有太大难度，后续还有很多内容需要跟随老师学习，希望后面能安排好时间，一直跟上老师讲课的进度。
