知识要点总结
# 1. JVM基本知识
## 1.1 Java语言本身的特点
面向对象的基于JVM虚拟机的半编译半解释型语言， 支持GC垃圾回收，支持二进制跨平台, 生态完整，生命力强
Java相对C++, Rust等其他语言的优势和劣势：
具备比较完善的GC机制，将内存的管理和回收都由JVM完成，对象的生命周期由JVM管理，设计哲学上讲，完全不信任程序员对内存的管理行为，一方面讲，将开发者从C++那样复杂的内存管理中解放出来，能够更多关注在业务逻辑上，但是同时也引入了GC的开销，在GC使用不当情况下会影响业务效率

## 1.2 Java程序运行基本机制
![image](https://github.com/xiaohaowudi/JAVA-000/blob/main/Week_01/images/Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.png)

应用开发者利用java编译器将java代码编译为字节码，每一个类对应一个字节码文件，程序运行时候首先是JVM虚拟机进程启动，作为所有Java程序的运行容器，由类装载器将类的字节码加载到内存中，加载到内存中的类就可以生成响应的对象，各个对象在特定的Java线程中运行自己的业务逻辑

## 1.3 字节码技术
Java程序本质上运行机制是由JVM执行Java源文件生成的字节码，可类比C++层序运行时候是由CPU运行汇编指令来理解，字节码本质就是JVM指令的二进制表现，通常通过类似于汇编的助记符提供给开发者阅读，可以通过javap等工具将二进制字节码反编译为助记符，开发者可通过程序的字节码分析代码逻辑并定位一些性能问题，JVM的字节码操作码由一个字节表示，至多支持256中不同操作码，除了一部分留给调试使用以外，现在已经使用的JVM指令操作码大概200个左右

本周简单学习了JVM的字节码原理，类装载器原理和JVM内存模型，在读书时候曾经接触过这些知识，但是没有非常深入去看，在老师讲解之后，自己动手写了几个实例程序用javap进行解析然后分析其字节码，其实Java字节码系统相对于硬件CPU的指令集系统已经简单了非常多，以前有过ARM平台上汇编代码的分析经验，再看Java的字节码系统，相对简单很多，Java字节码指令集本身很精简，LOAD STORE机制以及局部变量表配合一个内部栈进行计算，跟CPU中通用寄存器组配合ALU做算数运算的原理如出一辙。JMM内存模型相对以前有了一些更新换代，但是本质设计思想还是没有大的变化，趁着训练营机会正好把这些年没怎么关注的Java这一块的更新内容学习一下，装载器原理在读书时候就有过接触，通过作业中的简单代码事件也加深了一下理解，总体讲本节课涉及的内容大部分在读书时候接触过，少部分内容是自己盲区，不太了解，通过老师讲解和课后查阅资料已经进行了补习，作业内容相对简单，做起来没有太大难度，后续还有很多内容需要跟随老师学习，希望后面能安排好时间，一直跟上老师讲课的进度。
