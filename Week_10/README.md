学习笔记

#### 第十周学习总结

本周主要对分布式微服务架构的基本知识进行了学习，知识要点总结如下：



##### 分布式和集群的关系

集群中的节点是对等的，一般每个节点都包含全量的业务和数据，没有业务分工概念，只是简单的业务冗余镜像，可以分担流量，增加整个系统的业务容量；而分布式构架于集群之上，大系统中的节点被拆成不同的分组，不同的分组承担不同的职责，进行了业务分工，相互之间有协作关系，共同作为一个逻辑整体对外提供服务



##### 分布式服务场景中软件系统需要解决的共有问题和非业务功能性需求

1. 相同服务在集群中的分组和部署

2. 服务的注册与发现

3. 负载均衡，服务路由

4. 服务治理（熔断，限流，重试，容错等等）

5. 服务监控审计

RPC是一种实现非本地服务调用的技术思想，而完整的分布式服务化除了基于RPC实现服务之间的通信而外，更重要的是要解决上述的非功能性需求，形成完整的分布式服务运行的环境



##### 传统的ESB存在的问题

1. ESB是中间节点，如果ESB节点宕机，原来可以正常进行的服务调用全都不可用，需要集群保证高可用
2. ESB本身是中介者角色，两个不同系统之间的调用请求和响应必须经过ESB中转，会造成延迟
3. 大量复杂协议适配，安全认证，服务路由等功能全部集中在ESB里面，造成ESB系统非常重型，功能臃肿



##### 互联网业务中的SOA实现与传统ESB的区别

互联网业务中的服务调用出于效率考虑，要能够直接进行RPC调用，而不是ESB中中转的方案，所以将服务注册和配置提取到了配置中心和服务中心这样的旁路系统中，服务调用者从注册中心获取服务提供者信息，然后通过RPC直接对目标服务进行调用，即便注册中心不可用，原有的没有变更的服务也能被正常调用；RPC通信和服务治理一般通过在业务系统端集成系统框架的方式进行，分布式服务框架从注册中心获取服务相关的信息，服务路由，负载均衡等原有的ESB的服务治理增强功能被移动到了业务端，这样的结构是一种针对互联网业务的SOA实现



##### 分布式服务中的三大中心

###### 配置中心

管理整个分布式服务系统的配置参数，一般维护的是全局的和具体业务无关的配置信息，例如线程池大小，并发连接数等等



###### 注册中心

管理服务的注册信息，提供服务治理，服务路由等功能需要的运行期的服务信息，能够让对服务信息感兴趣的观察者实时感知到服务状态的变化

服务注册和服务发现一般的实现方式：

一般的实现方式是服务的提供者在上线时候时候将自己所提供的服务的信息主动注册给注册中心，在服务正常下线或者注册中心监测到服务已经不可用时候，将注册中心中的对应信息删除，对于服务信息的变更，注册中心需要具备将其通知给观察者的能力，一般服务的调用方都是该信息的观察者，调用方获取到注册中心的服务信息之后，再在调用端实现路由和负载均衡等增强功能，最终根据特定的策略选择出一个服务提供者，进行RPC调用



###### 元数据中心

管理核心的业务模型数据和服务的元信息，能够通过元数据中心获取到系统中所有服务模型信息



三大中心都是功能逻辑上的概念，并没有要求一定要部署在不同的物理节点上，也没有要求是独立的模块实体，都需要具备数据读写和数据变更通知的能力



##### 分布式服务常见的负载均衡策略

Random: 基于服务提供者的权重进行随机分配，权重高的节点获取到的请求数多

RoundRibin: 可用的服务提供者轮流提供服务

LeastActive: 当前已经接收且没有完成的任务数少的节点优先分配请求

ConsistentHashLoadBanlance: 基于一致性Hash的路由算法，将单个提供者映射为一系列不重复的逻辑数值点，将逻辑数值点部署在环状结构上，每次请求时候基于请求参数和其他特征信息将请求映射为一个hash数值，在环上查找第一个大于该hash数值的逻辑数值点，该逻辑数值点对应的服务提供者处理本次请求



##### 分布式服务中的流控方式

软件系统的服务容量是有上限的，当流量已经超过系统负载能力时候，有两种选择，一种是直接不提供服务，直到系统处理完积压的请求之后，在恢复服务，另外一种是保留部分核心服务的能力，暂停非核心业务逻辑，在问题解决之后再恢复所有的服务，第一种方式的保护级别比较高，一般情况下，会采用第二种选择，也就是所谓降级策略，在流量过大时候，都需要有类似的限制措施，防止大流量将整个系统冲垮，传统的流控方式一般是通过限制业务指标(例如单用户单日的交易次数)或者是限制线程数，并发调用数这些技术指标进行访问流量的限制，防止系统进入极端的繁忙状态，更高的保护级别下，一般会暂停接收新的请求，将积压的请求处理完成再恢复接收新请求



##### 微服务的一般结构

关联紧密的一系列软件功能模块对外提供一组独立的服务，每一组服务都运行在单独的进程中，采用REST，HTTP等接口给外部提供服务调用接口，系统外部通过网关路由请求，将请求投递给最终选择出来的服务提供者，内部独立的服务通过REST对其他模块提供服务访问接口，由注册中心，断路器等旁路系统提供服务治理，熔断等非功能呢性拓展功能



##### 微服务架构的演进趋势

**演进1 响应式微服务**

具备异步，弹性可伸缩，即时响应，可恢复，消息驱动几大特征

**演进2 服务网格和云原生**

将根业务无关的类似网络通信，控制策略等功能从业务中剥离，下沉到基础设施上，通过SideCar将真正的服务提供者隐蔽起来，所有SideCar对等形成网络互相连接，构成所谓的服务网格，服务调用通过SideCar之间的交互进行，由控制面板对SideCar进行统一的管理；后期通过微服务，容器化，Devops等技术的整合，形成云原生体系

**演进3 数据库网格**

对数据库也用SideCar的形式进行切分，形成数据网格，业务不需要自己查找数据库位置，只需要通过本地数据库SideCar的代理功能获取数据，让业务真正变成无状态的，更加轻量级

**演进4 单元化架构**

将功能完全但是只操作一部分数据的缩小版整站作为一个单元，以单元为粒度划分系统，将不同的单元部署在不同的独立的物理节点上，在业务调用的入口处进行流量分配和请求的路由



##### 单体结构和分布式微服务结构的开发效能对比

如果业务比较简单，单体架构一开始效能比较高，但是随着业务复杂度增加，会快速引入复杂度和各种模块间耦合度的提升，效能急剧下降，微服务架构的效能劣化相对缓慢，微服务结构因为一开始需要比较复杂的部署和拆分上的设计，所以一开始的效能相对低一点



##### 微服务改造的一般流程方法论

1. **调研** 从业务到技术分析清楚业务现状

2. **分析** 分析清楚系统改造之后每一层应该有哪些东西

3. **规划** 对比改造前和改造后的结构，规划好哪些层次先做哪些层次后做，层与层之间如何配合，形成规划

4. **组织** 相关的产品，研发，运维，测试团队沟通协调，哪些团队什么时间点完成什么任务，怎么对接，把应该对齐的东西对齐，形成共识
5. **拆分** 具体拆分业务，开发进行拆分实施，测试进行功能测试
6. **部署** 拆分后的系统进行实际部署
7. **治理** 验证服务拆分后的新系统是否达到预期，达不到预需要进行服务治理和调整

8. **改进** 复盘进行分析和总结，查找改进点进行改进，然后循环进行下一轮的调研

    所有步骤循环迭代，最终让微服务的结构收敛稳定



##### 微服务改造的一些最佳实践

1. 微服务的拆分是基于业务进行的，需要开发，业务，产品等不同角色的人同时参与分析，对如何拆分需要进行合理的设计，进行微服务改造时候需要首先思考清楚改造给业务带来的价值，不能为了拆而拆，业务拆分同时须进行数据拆分，拆分之后数据不能再耦合在一起，每个服务用自己的数据，只拆业务不拆数据没有太大价值，但是拆分数据的难度要远高于拆业务
2. 自然演进，逐步拆分，当前系统没有问题就不要单纯为了拆而做微服务演进，在中短期能够看到拆分的价值时候再进行拆分
3. 小步迭代，不要一开始就树立大目标执行，先进行局部的小型微服务改造
4. 灰度发布，不要把改造后的有风险的新功能直接一下全部暴露出去，逐步暴露，小步试错，降低风险
5. 改造的同时，将改造的部分的质量标准同时提升上去，不要停滞在老的质量标准下面

6. 业务部署时候一定要加特性开关和容错设计，实际线上老系统和新系统并存，逐步将流量替换到新系统上，如果发现新系统有问题，立刻将流量切回老系统，新系统在逐步处理更多流量之后，发现的问题都解决了再将老系统下线，使用新系统，新老系统切换一定要有缓冲区，不能直接刚性切换
7. 引入自动化部署和运维的手段，避免重复劳动
8. 慎用分布式事务，如果有其他方法能够解决业务上的问题，能不用分布式事务就不要用，必须注意幂等，去重，补偿，悬挂等问题
9. 引入运维监控，必须同时监控系统内部模块技术指标和上游业务指标，从业务上的异常反追技术上的问题，不要孤立地单纯从业务指标或者从技术指标去看待问题，看问题要有全局视角
10. 上线过程中发现问题或者和预期不符合的情况，马上回滚，不要在线上去补BUG