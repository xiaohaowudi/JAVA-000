### 第八周学习总结

本周主要对分布式事务相关内容进行学习，要点总结如下



#### 分布式事务

分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务，具体业务中多体现为对不同系统中的数据库分片进行全局一致的读写操作



#### 典型分布式事务产生场景

1. 典型的场景就是微服务架构 微服务之间通过远程调用完成事务操作

2. 单体系统访问多个数据库实例 当单体系统需要访问多个数据库(实例)时就会产生分布式事务

3. 多服务访问同一个数据库实例



#### CAP

**C - Consistency** 

一致性是指写操作后的读操作可以读取到最新的数据状态，当数据分布在多个节点上，从任意结点读取到的数据都
是最新的状态

**A - Availability**

可用性是指任何事务操作都可以得到响应结果，且不会出现响应超时或响应错误

**P - Partition tolerance**

 分区耐受性指部分节点失效，整体仍然可以对外提供服务

在所有分布式事务场景中不会同时具备CAP三个特性，因为在具备了P的前提下C和A是不能共存的，而P是分布式系统中必须具备的基本特性，因此分布式系统中常用CP或者AP的特性组合

**AP组合**

放弃一致性，追求分区容忍性和可用性。这是很多分布式系统设计时的选择，前提是只要用户可以接受所查询的到数据在一定时间内不是最新的，通常实现AP都会保证最终一致性

**CP组合**

放弃可用性，追求一致性和分区容错性，zookeeper追求的强一致的一种实现，CP中不允许出现外部读取到不一致的状态的情况

**CA组合**

放弃分区容忍性，即不进行分区，不考虑由于网络不通或结点挂掉的问题，则可以实现一致性和可用性。那么系统将不是一个标准的分布式系统，我们最常用的关系型数据就满足了CA

一个分布式系统最多只能同时满足 一致性(Consistency)、可用性(Availability)和分区容忍性(Partition tolerance)这三项中的两项。它可以作 为我们进行架构设计、技术选型的考量标准。对于多数大型互联网应用的场景，结点众多、部署分散，而且现在的 集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性，并要达到良好的响应性能来提高用户体验，因此一般都会做出如下选择:保证P和A，舍弃C强一致，保证最终一致性

**强一致性和最终一致性**

CAP中的一致性要求 在任何时间查询每个结点数据都必须一致，它强调的是强一致性，但是最终一致性是允许可以在一段时间内每个结 点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性



**刚性事务**

严格满足ACID四个特性的事务称之为刚性事务，分布式的刚性事务常基于XA标准进行实现，由于效率低下实际业务中使用较少



#### BASE柔性事务

BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩 写。BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证 核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，称之为“柔性事务”。

**基本可用**

分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如，电商网站交易付款出 现问题了，商品依然可以正常浏览

**软状态**

由于不要求强一致性，所以BASE允许系统中存在中间状态(也叫软状态)，这个状态不影响系统可用 性，如订单的"支付中"、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态

**最终一致**

最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的"支付中"状态，最终会变 为“支付成功”或者"支付失败"，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待



#### 常见的分布式事务的解决方案

**2PC**

2PC即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段(Prepare phase)、提交阶段(commit phase)，2是指两个阶段，P是指准备阶段，C是指提交阶段，主流的数据库产品对于2PC都进行了支持

**准备阶段(Prepare phase)**

事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事务，并写本地的Undo/Redo日志，此时事务没有提交

**提交阶段(commit phase)**

如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者 发送回滚(Rollback)消息;否则，发送提交(Commit)消息;参与者根据事务管理器的指令执行提交或者回滚操 作，并释放事务处理过程中使用的锁资源

为了统一标准减少行业内不必要的对 接成本，需要制定标准化的处理模型及接口标准，国际开放标准组织Open Group定义了分布式事务处理模型 DTP(Distributed Transaction Processing Reference Model)

DTP模型定义了分布式事务管理中的3中角色：

**AP(Application Program)**

即应用程序，可以理解为使用DTP分布式事务的程序

**RM(Resource Manager)**

即资源管理器，可以理解为事务的参与者，一般情况下是指一个数据库实例，通过资源管理器对该数据库进行控制，资源管理器控制着分支事务

**TM(Transaction Manager)**

事务管理器，负责协调和管理事务，事务管理器控制着全局事务，管理事务生命 周期，并协调各个RM。全局事务是指分布式事务处理环境中，需要操作多个数据库共同完成一个工作，这个 工作即是一个全局事务



**XA方案**

DTP模型定义TM和RM之间通讯的接口规范叫XA，基于数据库的XA 协议来实现2PC又称为XA方案，TM向AP提供 应用程序编程接口，AP通过TM提交及回滚事务，AP通过TM控制了事务的边界，TM通过XA接口来通知RM数据库事务的开始、结束以及提交、回滚，TM在分布式事务中充当了中介者的角色

XA方案存在的问题：

 1、需要本地数据库支持XA协议

 2、资源锁需要等到两个阶段结束才释放，锁时间长，性能较差



**Seata 2PC方案**

阿里的开源的分布式事务框架，通过对本地关系数据库的分支事务的协调来驱动完成全局事务，是工作在应用层的中间件。主要优点是性能较好，且不长时间占用连接资源，它以高效并且对业务0侵入的方式解决微服务场景下面临的分布式事务问题

Seata把一个分布式事务理解成一个包含了若干分支事务的全局事务。全局事务的职责是协调其下管辖的分支事务 达成一致，要么一起成功提交，要么一起失败回滚。此外，通常分支事务本身就是一个关系数据库的本地事务

Seata中三个组件：

**Transaction Coordinator (TC)**

事务协调器，它是独立的中间件，需要独立部署运行，它维护全局事务的运行状态，接收TM指令发起全局事务的提交与回滚，负责与RM通信协调各各分支事务的提交或回滚 

**Transaction Manager (TM)**

 事务管理器，TM需要嵌入应用程序中工作，它负责开启一个全局事务，并最终 向TC发起全局提交或全局回滚的指令

**Resource Manager (RM)**

控制分支事务，负责分支注册、状态汇报，并接收事务协调器TC的指令，驱动分 支(本地)事务的提交和回滚。

**Seata 2PC 和传统 XA 2PC的差别**

架构层次方面，传统2PC方案的 RM 实际上是在数据库层，RM本质上就是数据库自身，通过 XA 协议实现，而Seata的 RM 是以jar包的形式作为中间件层部署在应用程序这一侧的。 两阶段提交方面，传统2PC无论第二阶段的决议是commit还是rollback，事务性资源的锁都要保持到Phase2完成才释放。而Seata的做法是在Phase1 就将本地事务提交，这样就可以省去Phase2持锁的时间，整体提高效率，如果出现错误，通过逆命令反向SQL方式将已经提交的结果回滚回提交前的状态



**TCC柔性事务方案**

TCC是Try、Confirm、Cancel三个词语的缩写，TCC要求每个分支事务实现三个操作:预处理Try、确认 Confirm、撤销Cancel

Try操作做业务检查及资源预留，Confirm做业务确认操作，Cancel实现一个与Try相反的 操作即回滚操作。TM首先发起所有的分支事务的try操作，任何一个分支事务的try操作执行失败，TM将会发起所 有分支事务的Cancel操作，若try操作全部成功，TM将会发起所有分支事务的Confirm操作，其中Confirm/Cancel 操作若执行失败，TM会进行重试



**TCC 三个操作**

1. Try 操作是做业务检查(一致性)及资源预留(隔离)，此阶段仅是一个初步操作，它和后续的Confirm 一起才能 真正构成一个完整的业务逻辑
2. Confirm 操作是做确认提交，Try阶段所有分支事务执行成功后开始执行 Confirm。通常情况下，采用TCC则 认为 Confirm阶段是不会出错的。即:只要Try成功，Confirm一定成功。若Confirm阶段真的出错了，需引 入重试机制或人工处理
3.  Cancel 操作是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采 用TCC则认为Cancel阶段也是一定成功的。若Cancel阶段真的出错了，需引入重试机制或人工处理



**TCC需要解决的三种异常场景**

1. 空回滚 在没有调用 TCC 资源 Try 方法的情况下，调用了二阶段的 Cancel 方法，Cancel 方法需要识别出这是一个空回 滚，然后直接返回成功

2. TCC 的二阶段 Try、 Confirm 和 Cancel 接口保证幂等，这样不会重复使用或者释放资源。如果幂等控制没有做好，很有可能导致数据 不一致等严重问题
3. 悬挂 对于一个分布式事务，其Cancel 接口比Try 接口先执行，Try操作必须要能够识别出其对应的二阶段Cancel是否已经执行过，如果已经执行过，则不执行Try操作



**一些典型的TCC解决方案**

tcc-transaction

Hmily

ByteTCC

EasyTransaction
