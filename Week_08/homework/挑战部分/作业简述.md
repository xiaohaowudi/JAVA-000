### 挑战部分作业



#### 挑战作业1

要求：

(选做☆)设计实现一个简单的XA分布式事务框架demo，只需要能管理和调用2 个MySQL的本地事务即可，不需要考虑全局事务的持久化和恢复、高可用等

实现简述：

目录distributed_transaction_ax下为根据2PC XA方案实现的简单分布式事务管理框架，按照标准模型分别抽象了App, RM, TM 三个角色，实现了prepare, commit两个阶段的提交，在DistributedTransactionAxApplicationTests类中对成功和回滚两种场景进行了单元测试，笔者在自己环境上192.168.3.144和192.168.3.146两台独立主机上部署了两个独立的MySQL实例，且均在java_camp库下面构建了相同结构的测试表，建表语句如下：

```mysql
use java_camp;
create table t_id_name (
    id bigint primary key auto_increment,
    name varchar(20) not null
);
```

在回滚场景中，分别在两个数据源上执行两个分支事务，事务语句如下：

```java
String[] sqls1 = new String[] {
                "insert into t_id_name (id, name) values (300, 'XiaoMing100')",
                "insert into t_id_name (id, name) values (400, 'XiaoHong200')",
        };

        String[] sqls2 = new String[] {
                "insert into t_id_name (id, name) values (5000, 'XiaoMing1000')",
                "insert into t_id_name (id, name) values (5000, 'XiaoHong2000')",   // 故意构造主键重复错误，触发回滚
        };
```

第二个分支事务故意构造主键重复错误，触发全局事务回滚，经过验证，两个分支事务均回滚成功，实现了分布式事务回滚功能，正常执行分布式事务的测试用例中，两个分支事务的SQL语句如下：

```java
String[] sqls1 = new String[] {
            "insert into t_id_name (id, name) values (100, 'XiaoMing100')",
            "insert into t_id_name (id, name) values (200, 'XiaoHong200')",
        };

        String[] sqls2 = new String[] {
            "insert into t_id_name (id, name) values (1000, 'XiaoMing1000')",
            "insert into t_id_name (id, name) values (2000, 'XiaoHong2000')",
        };
```

经验证，全局事务正常执行，两个数据源均正常插入数据，具体代码清参照distributed_transaction_ax目录下文件



#### 挑战作业2

要求：

(选做☆)设计实现一个TCC分布式事务框架的简单Demo，需要实现事务管理器， 不需要实现全局事务的持久化和恢复、高可用等

实现简述：

distributed_transaction_tcc目录下为基于TCC实现的简单分布式事务框架，同样按照标准模型分别抽象了App, RM, TM 三个角色，由TM调度全局事务的try, commit, cancel操作，TCC三个操作具体由业务层的App对象实现，单元测试代码位于DistributedTransactionTccApplicationTests类中， 与挑战作业1的测试场景相同，分别测试全局事务正常执行和回滚，经验证两种场景的分布式事务执行都与预期一致，具体实现参见distributed_transaction_tcc下代码















