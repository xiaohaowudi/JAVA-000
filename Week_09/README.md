学习笔记

本周主要对RPC框架原理和Dubbo框架实例原理进行了学习，要点总结如下：



#### RPC框架需要实现的技术要点：

1. 实体类和服务的接口客户端和服务端都要有，且须一致，服务提供方对接口进行实现，服务消费方按照接口进行远程调用，双方实现依赖倒置
2. 拦截客户端的本地调用，用代理方式替换原来的本地调用，改为远程调用服务，代理的过程对于调用方不可见
3. 请求和响应中的对象需要进行序列化或者反序列化，文本的序列化方式缺点在于序列化出来的数据比较大，但是可读性好，二进制的序列化方式相对数据量小，数据不可读，一般选用二进制方式，序列化和反序列化开销小
4. 需选择合适的数据传输方式，常见的传输方式有TCP和HTTP，TCP相对效率高一些，但是控制复杂，有安全需求场景还需使用SSL隧道加密包装传输的数据
5. 服务端需提供服务的查找和路由功能，一般通过注册中心方式实现



#### Dubbo框架的核心功能

##### 基于接口和动态代理的远程方法调用

Dubbo对开发者屏蔽的底层的调用细节，在业务中使用远程服务和调用本地接口一样方便，对业务代码的侵入小

##### 负载均衡

Duboo内置多种负载均衡策略，能够感知下游节点的健康状况，减少调用延迟，提高系统吞吐量

##### 集群容错

Dubbo提供了Cluster组件用于做集群容错，提供了多种容错策略

##### 服务治理

支持多种注册中心服务，服务实例上下线能够被Dubbo实时感知，提供了完整的服务注册，服务发现，服务上下线的机制，提供了可视化的Dubbo Admin工具，可以对服务进行可视化管理



#### Dubbo的核心组件

##### Registry组件

服务注册模块，支持Multicast, Zookeeper, Nacos, Redis, Simple等多种注册中心模式，注册中心承担了服务治理中注册，发现，心跳和下线等功能，不承担消息的转发，Dubbo的注册中心基于长连接感知服务提供者的状态，服务提供者如果下线，注册中心将立即推送事件给消费者，同时会在服务列表中剔除服务提供者，注册中心自己的宕机不会影响已经上线运行的服务提供者和消费者

##### Monitor组件

服务监控中心提供对服务监控的功能，通过收集服务的调用时间等数据实现，是可选组件，监控中心的宕机不会影响任何服务的调用

##### Cluster组件

集群模块是服务提供者和消费者之间的中间层，将多个服务提供者合并为一个Cluster Invoker，并将Invoker暴露给服务消费者，为消费者屏蔽了服务提供者的具体细节，消费者只需要通过Involer进行远程调用

几种不同类型的Cluster Invoker提供了不同的容错策略:

Failover Cluster: 调用失败时，自动切换Invoker进行重试

Failback Cluster: 调用失败后，返回空结果给消费者，并通过定时任务对失败的调用进行重传

Failfast Cluster: 只会进行一次调用，失败后立刻抛出异常

Failsafe Cluster: 只会发起一次调用，失败后不会抛出异常，记录错误日志，然后给消费者返回空的响应

Forking Cluster: 通过线程池开启多个线程，对服务提供者同时发起调用，任意一个线程返回成功就会结束方法的调用，使用场景比较局限，多用在对实时性要求极高的场合



#### Dubbo框架支持的通信协议

Dubbo协议

RMI

Hessian

Http

WebService

REST

其他还支持Thrift, Memcached, Redis等等，使用比较少



#### Dubbo 的负载均衡策略

##### RandomLoadBanlance

按照服务器的权重大小给服务器分配数值区间，每次产生随机数，随机数落在哪个区间，就由这个区间对应的服务提供者来提供服务

##### LeastActiveLoadBanlance

最近活跃调用越少，认为服务器的处理性能越高，越能处理更多请求，因此偏向于将请求发送给最近活跃调用少的服务器处理

##### ConsistentHashLoadBanlance

基于一致性Hash的负载均衡策略，将物理节点映射为一系列逻辑节点，将逻辑节点随机分布到到环状结构上，每次随机选举逻辑节点编号，由第一个编号大于随机值的逻辑节点对应的物理节点提供服务

##### RoundRobinLoadBanlance

请求轮流分配给每台服务器，最后一个节点派发完之后从第一个节点重新开始派发

